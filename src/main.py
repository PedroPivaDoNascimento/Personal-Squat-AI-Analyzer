import streamlit as st
import pandas as pd
import os
import cv2

from classes.personal_ai import PersonalAI
from ultils.feedback_messages import feedback_messages
from classes.squat_report_excel_writer import SquatReportExcelWriter

MODEL_PATH = 'models/pose_landmarker_full.task'

def setup_app_ui(): 
    """
    Configura a interface do usu√°rio do Streamlit, incluindo t√≠tulo,
    campos de entrada e sliders de par√¢metros.
    Retorna os valores dos par√¢metros e o arquivo de v√≠deo enviado.
    """

    st.title('An√°lise Sagital Direita - Agachamento')
    name_input = st.text_input('Nome da pessoa')
    uploaded_file = st.file_uploader('Envie o v√≠deo (Sagital Direita)', type=['mp4', 'avi', 'mov'])

    st.write('### Par√¢metros de Avalia√ß√£o do Exerc√≠cio')
    col_param1, col_param2 = st.columns(2)
    with col_param1:
        descent_th = st.slider('Sensibilidade da Descida (Repeti√ß√£o)', 0.01, 0.10, 0.05, 0.005, format='%.3f', help="Percentual de movimento da orelha para baixo para iniciar a contagem da repeti√ß√£o.")
        trunk_err_th = st.slider('Toler√¢ncia de Desvio - Tronco (Dura√ß√£o Permitida)', 1, 20, 5, 1, help="N√∫mero de instantes que o tronco pode estar desalinhado antes de ser considerado um erro na repeti√ß√£o.")
        head_err_th = st.slider('Toler√¢ncia de Desvio - Cabe√ßa (Dura√ß√£o Permitida)', 1, 20, 5, 1, help="N√∫mero de instantes que a cabe√ßa pode estar desalinhada antes de ser considerado um erro na repeti√ß√£o.")
    with col_param2:
        ascent_return_th = st.slider('Toler√¢ncia de Retorno na Subida (Repeti√ß√£o)', 0.005, 0.05, 0.02, 0.005, format='%.3f', help="Percentual de proximidade da posi√ß√£o inicial da orelha para finalizar a contagem da repeti√ß√£o.")
        knee_err_th = st.slider('Toler√¢ncia de Desvio - Joelho (Dura√ß√£o Permitida)', 1, 20, 5, 1, help="N√∫mero de instantes que o joelho pode estar desalinhado antes de ser considerado um erro na repeti√ß√£o.")
        foot_err_th = st.slider('Toler√¢ncia de Desvio - Calcanhar (Dura√ß√£o Permitida)', 1, 20, 5, 1, help="N√∫mero de instantes que o calcanhar pode estar levantado antes de ser considerado um erro na repeti√ß√£o.")

    params = {
        'descent_threshold': descent_th,
        'ascent_return_threshold': ascent_return_th,
        'trunk_error_threshold': trunk_err_th,
        'knee_error_threshold': knee_err_th,
        'head_error_threshold': head_err_th,
        'foot_error_threshold': foot_err_th
    }
    return name_input, uploaded_file, params

def process_and_analyze_video(uploaded_file, name_input, params):
    """
    Salva o v√≠deo temporariamente, inicializa a IA e processa o v√≠deo.
    Retorna a inst√¢ncia do PersonalAI ap√≥s a an√°lise.
    """
    # Extrai a extens√£o do arquivo original
    ext = os.path.splitext(uploaded_file.name)[1]
    # Cria um nome de arquivo tempor√°rio
    temp_path = f'temp_sag_dir{ext}'

    # Salva o conte√∫do do arquivo enviado em disco
    with open(temp_path, 'wb') as f:
        f.write(uploaded_file.getbuffer())
    st.info('Analisando v√≠deo...')

    # --- C√°lculo da dura√ß√£o total do v√≠deo em segundos ---
    cap = cv2.VideoCapture(temp_path)
    fps = cap.get(cv2.CAP_PROP_FPS)
    frame_count = int(cap.get(cv2.CAP_PROP_FRAME_COUNT))
    total_video_duration_seconds = frame_count / fps if fps > 0 else 0
    cap.release()
    # --- FIM DO C√ÅLCULO ---

    # Inicializa a classe PersonalAI com os par√¢metros do usu√°rio
    ai = PersonalAI(
        temp_path, name_input, MODEL_PATH,
        **params # Desempacota o dicion√°rio de par√¢metros
    )
    # Processa o v√≠deo. draw=True e display=True s√£o para visualiza√ß√£o durante o processo.
    ai.process_video(True, True) 
    st.success('An√°lise conclu√≠da!')

    excel_writer = SquatReportExcelWriter(name_input, ai.squat_analyzer)
    excel_writer.generate_report(total_video_duration_seconds)     
    # Limpa o arquivo tempor√°rio ap√≥s o processamento
    os.remove(temp_path)
    return ai

def display_overall_summary(ai_analyzer, name):
    """
    Exibe um resumo geral das repeti√ß√µes detectadas.
    """
    st.markdown(f"""
    ---
    ## Resultados da An√°lise para: **{name}**
    ---
    """)
    st.write(f'### Resumo das Repeti√ß√µes Detectadas: {ai_analyzer.repetitions_detected}')

def display_detailed_charts(ai_analyzer):
    """
    Gera e exibe gr√°ficos de barras individuais para cada repeti√ß√£o detectada,
    mostrando a contagem de desvios por parte do corpo.
    """
    st.write('### An√°lise Detalhada de Desvios por Repeti√ß√£o')
    st.markdown("""
    Abaixo, voc√™ encontrar√° um gr√°fico de barras para cada uma das repeti√ß√µes analisadas.
    Cada gr√°fico mostra a quantidade de desvios para diferentes partes do corpo.
    """)

    for i in range(len(ai_analyzer.trunk_error_history)):
        if ai_analyzer.trunk_error_history[i] is not None:
            st.write(f'#### Repeti√ß√£o {i+1}') # T√≠tulo para o gr√°fico da repeti√ß√£o atual
            
            # Prepara os dados para o gr√°fico de barras desta repeti√ß√£o espec√≠fica.
            rep_error_data = {
                'Parte do Corpo': ['Tronco', 'Joelho', 'Cabe√ßa', 'Calcanhar'],
                'Contagem de Erros': [
                    ai_analyzer.trunk_error_history[i],  # Erros de tronco para esta repeti√ß√£o
                    ai_analyzer.knee_error_history[i],   # Erros de joelho para esta repeti√ß√£o
                    ai_analyzer.head_error_history[i],   # Erros de cabe√ßa para esta repeti√ß√£o
                    ai_analyzer.foot_error_history[i]    # Erros de calcanhar para esta repeti√ß√£o
                ]
            }
            
            # Cria um DataFrame Pandas para esta √∫nica repeti√ß√£o, definindo 'Parte do Corpo' como √≠ndice.
            df_rep_errors = pd.DataFrame(rep_error_data).set_index('Parte do Corpo')
            
            # Exibe o gr√°fico de barras para a repeti√ß√£o atual.
            st.bar_chart(df_rep_errors, use_container_width=True, height=300)
            st.markdown("---") # Adiciona um separador visual entre os gr√°ficos
        else:
            # Se o slot da repeti√ß√£o for None (n√£o detectada/completa), exibe uma mensagem.
            st.write(f'#### Repeti√ß√£o {i+1}: N√£o Detectada')
            st.info(f"N√£o h√° dados completos para a Repeti√ß√£o {i+1}. O agachamento pode n√£o ter sido conclu√≠do ou detectado.")
            st.markdown("---") # Adiciona um separador visual

def display_repetition_details_and_feedback(ai_analyzer):
    """
    Exibe detalhes textuais para cada repeti√ß√£o, incluindo status OK/DESVIO
    e mensagens de feedback espec√≠ficas.
    """
    st.write('### Detalhes por Repeti√ß√£o')
    # Itera sobre o n√∫mero de repeti√ß√µes registradas (inclusive as preenchidas com None)
    for i in range(len(ai_analyzer.reps['trunk'])):
        # Verifica se a repeti√ß√£o atual tem dados reais ou √© um slot None
        if ai_analyzer.reps['trunk'][i] is not None and ai_analyzer.repetition_timestamps[i] is not None:
            st.markdown(f"#### Repeti√ß√£o {i+1} (Finalizada em {ai_analyzer.repetition_timestamps[i]:.2f} segundos)")
            
            # Determina o status de OK/DESVIO para cada parte do corpo
            trunk_status = "DESVIO ‚ùå" if ai_analyzer.reps['trunk'][i] == 1 else "OK ‚úÖ" 
            knee_status = "DESVIO ‚ùå" if ai_analyzer.reps['knee'][i] == 1 else "OK ‚úÖ" 
            head_status = "DESVIO ‚ùå" if ai_analyzer.reps['head'][i] == 1 else "OK ‚úÖ" 
            heel_status = "DESVIO ‚ùå" if ai_analyzer.reps['heel'][i] == 1 else "OK ‚úÖ" 

            # Exibe o status e a contagem de instantes de desvio
            st.markdown(f"- **Tronco:** {trunk_status} ({ai_analyzer.trunk_error_history[i]} instantes)") 
            st.markdown(f"- **Joelho:** {knee_status} ({ai_analyzer.knee_error_history[i]} instantes)") 
            st.markdown(f"- **Cabe√ßa:** {head_status} ({ai_analyzer.head_error_history[i]} instantes)") 
            st.markdown(f"- **Calcanhar:** {heel_status} ({ai_analyzer.foot_error_history[i]} instantes)") 

            st.write("---") # Separador visual
            st.write("**Feedback para esta repeti√ß√£o:**")
            feedback_given = False
            # Exibe mensagens de feedback espec√≠ficas se houver desvio
            if ai_analyzer.reps['trunk'][i] == 1:
                st.info(f"üí° {feedback_messages['trunk_error']}")
                feedback_given = True
            if ai_analyzer.reps['knee'][i] == 1:
                st.info(f"üí° {feedback_messages['knee_error']}")
                feedback_given = True
            if ai_analyzer.reps['head'][i] == 1:
                st.info(f"üí° {feedback_messages['head_error']}")
                feedback_given = True
            if ai_analyzer.reps['heel'][i] == 1:
                st.info(f"üí° {feedback_messages['heel_error']}")
                feedback_given = True
            
            # Se nenhum desvio foi detectado, exibe mensagem de sucesso
            if not feedback_given:
                st.success("‚úÖ **√ìtima execu√ß√£o!** Continue assim.")
            st.write("---") # Separador visual
        else:
            # Mensagem para slots de repeti√ß√£o que s√£o None (n√£o detectados)
            st.markdown(f"#### Repeti√ß√£o {i+1}: Detalhes Indispon√≠veis")
            st.info(f"Detalhes para a Repeti√ß√£o {i+1} n√£o est√£o dispon√≠veis, pois ela n√£o foi detectada ou conclu√≠da.")
            st.write("---") # Separador visual

def display_no_repetitions_found_message():
    """
    Exibe uma mensagem quando nenhuma repeti√ß√£o completa √© detectada.
    """
    st.write('Nenhuma repeti√ß√£o foi detectada com os par√¢metros atuais. Por favor, verifique se o movimento de agachamento foi completo ou ajuste os par√¢metros de sensibilidade.')

def display_data_frames(ai):
    """
    Exibe DataFrames detalhados de desvios ponto a ponto,
    convertendo a coluna de tempo para segundos.
    Assume que os DataFrames (ai.head_df, ai.trunk_df, etc.)
    possuem uma coluna de tempo que precisa ser convertida.
    """
    st.write('### Detalhe da An√°lise Ponto a Ponto (Momentos de Desvio)')

    # Lista dos DataFrames a serem exibidos e os seus nomes para o t√≠tulo
    dataframes_to_display = {
        "Desvios da Cabe√ßa": ai.head_df,
        "Desvios do Tronco": ai.trunk_df,
        "Desvios do Calcanhar": ai.heel_df,
        "Desvios do Joelho": ai.knee_df
    }

    # Itera sobre cada DataFrame para processar e exibir
    for title, df in dataframes_to_display.items():
        if not df.empty: # Verifica se o DataFrame n√£o est√° vazio
            st.write(f'#### {title}')
            
            # Cria uma c√≥pia do DataFrame para evitar modificar o original
            df_display = df.copy()         
            time_column_name = 'Tempo (ms)'
    
            # Converte para segundos e arredonda para 2 casas decimais para melhor legibilidade
            df_display[time_column_name] = (df_display[time_column_name] / 1000).round(2)
            df_display.rename(columns={time_column_name: 'Tempo (s)'}, inplace=True)
    
            st.dataframe(df_display, use_container_width=True)
        else:
            st.write(f'#### {title}')
            st.info(f"Nenhum desvio registado para {title.lower()}.")
        st.markdown("---") # Separador visual entre os DataFrames

if __name__ == "__main__":
    name_input, uploaded_file, params = setup_app_ui()

    #Processa o v√≠deo se um arquivo for enviado e um nome for fornecido
    if uploaded_file and name_input:
        ai_instance = process_and_analyze_video(uploaded_file, name_input, params)
        
        # Exibir o resumo geral
        display_overall_summary(ai_instance.squat_analyzer, name_input)
        
        # Exibir gr√°ficos detalhados e feedback se houver repeti√ß√µes
        if ai_instance.squat_analyzer.repetitions_detected > 0:
            display_detailed_charts(ai_instance.squat_analyzer)
            display_repetition_details_and_feedback(ai_instance.squat_analyzer)
            display_data_frames(ai_instance)
        else:
            display_no_repetitions_found_message()

